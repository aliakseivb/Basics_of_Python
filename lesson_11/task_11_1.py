# 1. Реализовать класс «Дата».
# Техническое задание:
#
# Конструктор принимает дату (параметр) в виде строки формата «день-месяц-год».
# Методы объекта:
# Первый с декоратором @classmethod. Извлекает число, месяц, год из строки «день-месяц-год»,
# преобразовывает их к типу int. Возвращает три числа.
# Второй с декоратором @staticmethod. Проводит валидацию этих трех чисел, например, месяц — от 1 до 12,
# дней в месяце не более 31 - далее на ваш выбор. Вы можете использовать пакет datetime для проверки корректности даты.
# Подумайте что логично возвращать валидатору, какое значимое имя вы дадите этому методу?
# При создании объекта в конструкторе использовать оба указанных метода.
# Конструктор создает объект только если прошла валидация вторым методом.
# Объект «дата» хранится в виде трех чисел отдельно или в контейнере. В случае невозможности создать объект
# конструктор выкидывает исключение DateInitError c внятным диагностическим сообщением.
# Переопределить метод __str__ для печати числа в виде 2021.12.31
# Создать несколько экземпляров и распечатать их. Проверить работу на не валидных данных.
# Исключение от конструктора ловить в основном коде программы и подменять выводом диагностического сообщения (любого).
# Примеры/Тесты:
#
#
# >>> lst_date = ["31-12-2021", "32-12-2022", "12-12&##x2013;2022"]
# ...
# 2021.12.31
# Дата: 32-12-2022,  результат: Внятное диагностическое сообщение
# Дата: 12-12--2022, результат: Внятное диагностическое сообщение
# >>>
#
# Примечание:
#
# В задании предполагаем, что оба метода используются только для конструктора.
# Внутренние проверки вы можете сделать на основе концепций LBYL(проверки и обход «узких» мест)
# или EAFP(исключения и их обработка).
# Подумайте что логично возвращать методам в случае обоих концепций?

import re


class ValidDate:

    def __init__(self, dates):
        self.dates = dates

    @classmethod
    def receive_dates(cls, dates):
        try:
            re.search(r'(?P<data>\d{2}-+\d{2}-+\d{4})', dates)
            date = list(dates.split('-'))
            return cls.valid_dates(date)
        except ValueError:
            return f'date not found!'

    @staticmethod
    def valid_dates(date):
        if 31 >= int(date[0]) >= 1 and 12 >= int(date[1]) >= 1 and int(date[2]) >= 1:
            return f'{int(date[2])}.{int(date[1])}.{int(date[0])}'
        elif 31 < int(date[0]) or int(date[0]) < 1:
            return f'wrong day - {int(date[0])}'
        elif 1 > int(date[1]) or int(date[1]) > 12:
            return f'wrong month - {int(date[1])}'
        elif int(date[2]) < 1:
            return f'wrong year - {int(date[2])}'

    def __str__(self):
        return self.dates

if __name__ == '__main__':
    dates_list = ["31-12-2021", "32-12-2022", "12-12&##x2013;2022", "10-13-2022", "2&##x2013;2022", "01-01-0001"]
    for dates in dates_list:
        out = ValidDate.receive_dates(dates)
        print(f'received: {dates}  ///  found: {out}')
